{"version":3,"sources":["webpack:///webpack/bootstrap 82c6633cbeee6b17f6ce","webpack:///./~/_babel-runtime@6.26.0@babel-runtime/regenerator/index.js","webpack:///external \"koa-router\"","webpack:///./nuxt.config.js","webpack:///./server/routers/index.js","webpack:///external \"koa\"","webpack:///external \"nuxt\"","webpack:///./server/controllers/mock.js","webpack:///external \"regenerator-runtime\"","webpack:///./server/index.js","webpack:///external \"lodash\"","webpack:///./~/_http-proxy-middleware@0.17.4@http-proxy-middleware/lib/logger.js","webpack:///external \"url\"","webpack:///external \"util\"","webpack:///./~/_http-proxy@1.16.2@http-proxy/lib/http-proxy/common.js","webpack:///external \"http\"","webpack:///external \"https\"","webpack:///./~/_eventemitter3@1.2.0@eventemitter3/index.js","webpack:///./~/_http-proxy-middleware@0.17.4@http-proxy-middleware/index.js","webpack:///./~/_http-proxy-middleware@0.17.4@http-proxy-middleware/lib/config-factory.js","webpack:///./~/_http-proxy-middleware@0.17.4@http-proxy-middleware/lib/context-matcher.js","webpack:///./~/_http-proxy-middleware@0.17.4@http-proxy-middleware/lib/handlers.js","webpack:///./~/_http-proxy-middleware@0.17.4@http-proxy-middleware/lib/index.js","webpack:///./~/_http-proxy-middleware@0.17.4@http-proxy-middleware/lib/path-rewriter.js","webpack:///./~/_http-proxy-middleware@0.17.4@http-proxy-middleware/lib/router.js","webpack:///./~/_http-proxy@1.16.2@http-proxy/index.js","webpack:///./~/_http-proxy@1.16.2@http-proxy/lib/http-proxy.js","webpack:///./~/_http-proxy@1.16.2@http-proxy/lib/http-proxy/index.js","webpack:///./~/_http-proxy@1.16.2@http-proxy/lib/http-proxy/passes/web-incoming.js","webpack:///./~/_http-proxy@1.16.2@http-proxy/lib/http-proxy/passes/web-outgoing.js","webpack:///./~/_http-proxy@1.16.2@http-proxy/lib/http-proxy/passes/ws-incoming.js","webpack:///./~/_koa2-connect@1.0.2@koa2-connect/dist/index.js","webpack:///./~/_requires-port@1.0.0@requires-port/index.js","webpack:///external \"is-glob\"","webpack:///external \"micromatch\"","webpack:///./utils/config.js"],"names":["module","exports","head","title","meta","charset","name","content","hid","link","rel","type","href","css","plugins","loading","color","router","middleware","build","extend","config","ctx","isClient","rules","push","enforce","test","loader","exclude","use","mock","routes","allowedMethods","get","c2k","proxy","cfg","next","html","body","app","host","process","env","HOST","port","PORT","require","dev","nuxt","builder","status","Promise","resolve","reject","res","on","render","req","promise","then","catch","listen","console","log","start","target","changeOrigin","pathRewrite"],"mappings":";;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AChEA;;;;;;;ACAA,uC;;;;;;ACAAA,OAAOC,OAAP,GAAiB;AACf;;;AAGAC,QAAM;AACJC,WAAO,SADH;AAEJC,UAAM,CACJ,EAAEC,SAAS,OAAX,EADI,EAEJ,EAAEC,MAAM,UAAR,EAAoBC,SAAS,qCAA7B,EAFI,EAGJ,EAAEC,KAAK,aAAP,EAAsBF,MAAM,aAA5B,EAA2CC,SAAS,iBAApD,EAHI,CAFF;AAOJE,UAAM,CACJ,EAAEC,KAAK,MAAP,EAAeC,MAAM,cAArB,EAAqCC,MAAM,cAA3C,EADI;AAGN;AACA;AACA;AAZI,GAJS;AAkBf;;;AAGAC,OAAK,CAAC,sBAAD,CArBU;AAsBf;;;AAGAC,WAAS,CAAC,gBAAD,CAzBM;AA0Bf;;;AAGAC,WAAS,EAAEC,OAAO,SAAT,EA7BM;AA8Bf;;;AAGAC,UAAQ;AACNC,gBAAY;AADN,GAjCO;AAoCf;;;AAGAC,SAAO;AACL;;;AAGAC,UAJK,kBAIGC,MAJH,EAIWC,GAJX,EAIgB;AACnB,UAAIA,IAAIC,QAAR,EAAkB;AAChBF,eAAOrB,MAAP,CAAcwB,KAAd,CAAoBC,IAApB,CAAyB;AACvBC,mBAAS,KADc;AAEvBC,gBAAM,aAFiB;AAGvBC,kBAAQ,eAHe;AAIvBC,mBAAS;AAJc,SAAzB;AAMD;AACF;AAbI;AAvCQ,CAAjB,C;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;;AAEA,IAAIZ,SAAS,IAAI,kDAAJ,EAAb;AACAA,OAAOa,GAAP,CAAW,OAAX,EAAoB,kEAAAC,CAAKC,MAAL,EAApB,EAAmC,kEAAAD,CAAKE,cAAL,EAAnC;;AAEA;AACAhB,OAAOiB,GAAP,CAAW,oBAAX,EAAiC,oDAAAC,CAAI,6DAAAC,CAAM,8DAAAC,CAAID,KAAV,CAAJ,CAAjC;;AAEA,4CAAenB,MAAf,C;;;;;;ACZA,gC;;;;;;ACAA,iC;;;;;;;;;;;;;;;;;ACAA;;AAEA,IAAIc,OAAO,IAAI,kDAAJ,EAAX;;AAEAA,KAAKG,GAAL,CAAS,MAAT;AAAA,uNAAiB,iBAAOZ,GAAP,EAAYgB,IAAZ;AAAA;AAAA;AAAA;AAAA;AAAA;AACXC,gBADW;;AAOfjB,gBAAIkB,IAAJ,GAAWD,IAAX;;AAPe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAjB;;AAAA;AAAA;AAAA;AAAA;;AAUA,4CAAeR,IAAf,C;;;;;;ACdA,gD;;;;;;;;;;;;;;;;;;uNCIA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACQU,eADR,GACc,IAAI,2CAAJ,EADd;AAEQC,gBAFR,GAEeC,QAAQC,GAAR,CAAYC,IAAZ,IAAoB,WAFnC;AAGQC,gBAHR,GAGeH,QAAQC,GAAR,CAAYG,IAAZ,IAAoB,IAHnC;;AAKE;;AACI1B,kBANN,GAMe,mBAAA2B,CAAQ,CAAR,CANf;;AAOE3B,mBAAO4B,GAAP,GAAa,EAAER,IAAIG,GAAJ,KAAY,YAAd,CAAb;;AAEA;AACMM,gBAVR,GAUe,IAAI,0CAAJ,CAAS7B,MAAT,CAVf;;AAYE;;AAZF,iBAaMA,OAAO4B,GAbb;AAAA;AAAA;AAAA;;AAcUE,mBAdV,GAcoB,IAAI,6CAAJ,CAAYD,IAAZ,CAdpB;AAAA;AAAA,mBAeUC,QAAQhC,KAAR,EAfV;;AAAA;;AAkBE;AACAsB,gBAAIX,GAAJ,CAAQ,yDAAAb,CAAOe,MAAP,EAAR,EAAyBF,GAAzB,CAA6B,yDAAAb,CAAOgB,cAAP,EAA7B;;AAEA;AACAQ,gBAAIX,GAAJ;AAAA,oOAAQ,iBAAOR,GAAP,EAAYgB,IAAZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BACAA,MADA;;AAAA;AAENhB,4BAAI8B,MAAJ,GAAa,GAAb,CAFM,CAEW;AAFX,yDAGC,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtCjC,8BAAIkC,GAAJ,CAAQC,EAAR,CAAW,OAAX,EAAoBH,OAApB;AACAhC,8BAAIkC,GAAJ,CAAQC,EAAR,CAAW,QAAX,EAAqBH,OAArB;AACAJ,+BAAKQ,MAAL,CAAYpC,IAAIqC,GAAhB,EAAqBrC,IAAIkC,GAAzB,EAA8B,mBAAW;AACvC;AACAI,oCAAQC,IAAR,CAAaP,OAAb,EAAsBQ,KAAtB,CAA4BP,MAA5B;AACD,2BAHD;AAID,yBAPM,CAHD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAAR;;AAAA;AAAA;AAAA;AAAA;;AAaAd,gBAAIsB,MAAJ,CAAWjB,IAAX,EAAiBJ,IAAjB;AACAsB,oBAAQC,GAAR,CAAY,yBAAyBvB,IAAzB,GAAgC,GAAhC,GAAsCI,IAAlD,EApCF,CAoC0D;;AApC1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAeoB,K;;;;;;;AAJf;AACA;AACA;;AAyCAA,Q;;;;;;AC3CA,mC;;;;;;ACAA;AACA;;AAEA;;AAEA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,+CAA+C;;AAE/C,oCAAoC,oBAAoB,sCAAsC,oBAAoB,qCAAqC,oBAAoB,OAAO;;AAElL;AACA;;;;;;;AC7JA,gC;;;;;;ACAA,iC;;;;;;ACAA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,eAAe;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,+CAA+C;AAChE;;AAEA;AACA,8BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,uCAAuC;AACjD;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxPA,iC;;;;;;ACAA,kC;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0DAA0D,OAAO;AACjE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA,eAAe,YAAY;AAC3B;;AAEA;AACA,2DAA2D;AAC3D,+DAA+D;AAC/D,mEAAmE;AACnE;AACA,0DAA0D,SAAS;AACnE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,gDAAgD,YAAY;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChSA;;AAEA;AACA;AACA;;;;;;;ACJA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,+BAA+B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,eAAe;;AAElE;AACA;AACA;AACA,8BAA8B,+BAA+B;AAC7D,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA,kEAAkE,iCAAiC;AACnG;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+BAA+B;AAC7D;AACA,YAAY,OAAO;AACnB,YAAY,EAAE;AACd,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;AC7HA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC7FA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C;AAC9C;;AAEA,qEAAqE;;AAErE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,uFAAuF;AACvF;AACA,4FAA4F;;AAE5F;AACA;AACA;;;;;;;AClJA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS,2BAA2B;AACjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,0CAA0C;AAC1C;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;;AAEA;AACA;;;;;;;;ACtEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,gDAAgD;AAChD;AACA;AACA;AACA;AACA,SAAS;;AAET,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yC;;;;;;ACZA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,mCAAmC,KAAK;AACxC,cAAc,sCAAsC;AACpD;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,SAAS;AACrB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,oBAAoB;;AAExD;AACA;AACA;;AAEA;AACA,4DAA4D,4BAA4B,EAAE;AAC1F;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;;;;;;ACvLA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,gBAAgB;AAC7B,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,gBAAgB;AAC7B,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,gBAAgB;AAC7B,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,gBAAgB;AAC7B,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,kBAAkB;AAC7C;;AAEA;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA,kBAAkB,sDAAsD;AACxE,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,6CAA6C;AAC/D,kBAAkB,kBAAkB;AACpC,mDAAmD,OAAO;AAC1D;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;;AAEL;AACA;;AAEA;;;;;;;ACnLA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,gBAAgB;AAC7B,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,gBAAgB;AAC7B,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,gBAAgB;AAC7B,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD;AACxD,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,gCAAgC;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,gBAAgB;AAC7B,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;;;;;;ACzIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA,4CAA4C;AAC5C;;AAEA;AACA,iBAAiB,iEAAiE;;AAElF;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA,8CAA8C;AAC9C,KAAK;;AAEL,0BAA0B;;AAE1B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3JA;AACA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA;AACA,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,YAAY;AACZ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK,EAAE;AACP;AACA;;;;;;;;ACxJA;;AAEA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;ACrCA,oC;;;;;;ACAA,uC;;;;;;;ACAA,4CAAe;AACb,aAAW,YADE;AAEb,iBAAe,GAFF;AAGb,eAAa,CAAC,QAAD,CAHA;AAIb,gBAAc,KAJD;AAKb,WAAS;AACPC,YAAQ,iEADD;AAEPC,kBAAc,IAFP;AAGPC,iBAAa;AACX,eAAS;AADE;AAHN;AALI,CAAf,C","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 82c6633cbeee6b17f6ce","module.exports = require(\"regenerator-runtime\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_babel-runtime@6.26.0@babel-runtime/regenerator/index.js\n// module id = 0\n// module chunks = 0","module.exports = require(\"koa-router\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"koa-router\"\n// module id = 1\n// module chunks = 0","module.exports = {\n  /*\n  ** Headers of the page\n  */\n  head: {\n    title: 'starter',\n    meta: [\n      { charset: 'utf-8' },\n      { name: 'viewport', content: 'width=device-width, initial-scale=1' },\n      { hid: 'description', name: 'description', content: 'Nuxt.js project' }\n    ],\n    link: [\n      { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' }\n    ]\n    // script: [\n    //   { src: 'jquery/dist/jquery.min.js' }\n    // ]\n  },\n  /*\n  ** Global CSS\n  */\n  css: ['~assets/css/main.css'],\n  /*\n  ** plugins\n  */\n  plugins: ['~plugins/index'],\n  /*\n  ** Customize the progress-bar color\n  */\n  loading: { color: '#3B8070' },\n  /*\n  ** router middleware\n  */\n  router: {\n    middleware: 'currentRoute'\n  },\n  /*\n   ** Build configuration\n   */\n  build: {\n    /*\n     ** Run ESLINT on save\n     */\n    extend (config, ctx) {\n      if (ctx.isClient) {\n        config.module.rules.push({\n          enforce: 'pre',\n          test: /\\.(js|vue)$/,\n          loader: 'eslint-loader',\n          exclude: /(node_modules)/\n        })\n      }\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./nuxt.config.js","import Router from 'koa-router'\nimport c2k from 'koa2-connect'\nimport proxy from 'http-proxy-middleware'\nimport mock from './../controllers/mock'\nimport cfg from './../../utils/config'\n\nlet router = new Router()\nrouter.use('/mock', mock.routes(), mock.allowedMethods())\n\n// 代理proxy 转发所有本地的 /api 请求\nrouter.get(/^\\/api(\\/|\\/\\w+)?$/, c2k(proxy(cfg.proxy)))\n\nexport default router\n\n\n\n// WEBPACK FOOTER //\n// ./server/routers/index.js","module.exports = require(\"koa\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"koa\"\n// module id = 4\n// module chunks = 0","module.exports = require(\"nuxt\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"nuxt\"\n// module id = 5\n// module chunks = 0","import Router from 'koa-router'\n\nlet mock = new Router()\n\nmock.get('/one', async (ctx, next) => {\n  let html = `\n    <ul>\n      <li><a href=\"/page/helloworld\">/page/helloworld</a></li>\n      <li><a href=\"/page/404\">/page/404</a></li>\n    </ul>\n  `\n  ctx.body = html\n})\n\nexport default mock\n\n\n\n// WEBPACK FOOTER //\n// ./server/controllers/mock.js","module.exports = require(\"regenerator-runtime\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"regenerator-runtime\"\n// module id = 7\n// module chunks = 0","import Koa from 'koa'\nimport { Nuxt, Builder } from 'nuxt'\nimport router from './routers'\n\nasync function start () {\n  const app = new Koa()\n  const host = process.env.HOST || '127.0.0.1'\n  const port = process.env.PORT || 3000\n\n  // Import and Set Nuxt.js options\n  let config = require('../nuxt.config.js')\n  config.dev = !(app.env === 'production')\n\n  // Instantiate nuxt.js\n  const nuxt = new Nuxt(config)\n\n  // Build in development\n  if (config.dev) {\n    const builder = new Builder(nuxt)\n    await builder.build()\n  }\n\n  // 加载路由中间件\n  app.use(router.routes()).use(router.allowedMethods())\n\n  // http status 404 改 200\n  app.use(async (ctx, next) => {\n    await next()\n    ctx.status = 200 // koa defaults to 404 when it sees that status is unset\n    return new Promise((resolve, reject) => {\n      ctx.res.on('close', resolve)\n      ctx.res.on('finish', resolve)\n      nuxt.render(ctx.req, ctx.res, promise => {\n        // nuxt.render passes a rejected promise into callback on error.\n        promise.then(resolve).catch(reject)\n      })\n    })\n  })\n\n  app.listen(port, host)\n  console.log('Server listening on ' + host + ':' + port) // eslint-disable-line no-console\n}\n\nstart()\n\n\n\n// WEBPACK FOOTER //\n// ./server/index.js","module.exports = require(\"lodash\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash\"\n// module id = 9\n// module chunks = 0","var util = require('util');\nvar _ = require('lodash');\n\nvar loggerInstance;\n\nvar defaultProvider = {\n    log: console.log,\n    debug: console.log,    // use .log(); since console does not have .debug()\n    info: console.info,\n    warn: console.warn,\n    error: console.error\n};\n\n// log level 'weight'\nvar LEVELS = {\n    debug: 10,\n    info: 20,\n    warn: 30,\n    error: 50,\n    silent: 80\n};\n\nmodule.exports = {\n    // singleton\n    getInstance: function() {\n        if (!loggerInstance) {\n            loggerInstance = new Logger();\n        }\n\n        return loggerInstance;\n    },\n    getArrow: getArrow\n};\n\nfunction Logger() {\n    var logLevel;\n    var provider;\n\n    var api = {\n        log: log,\n        debug: debug,\n        info: info,\n        warn: warn,\n        error: error,\n        setLevel: function(v) {\n            if (isValidLevel(v)) {\n                logLevel = v;\n            }\n        },\n        setProvider: function(fn) {\n            if (fn && isValidProvider(fn)) {\n                provider = fn(defaultProvider);\n            }\n        }\n    };\n\n    init();\n\n    return api;\n\n    function init() {\n        api.setLevel('info');\n        api.setProvider(function() {\n            return defaultProvider;\n        });\n    }\n\n    // log will log messages, regardless of logLevels\n    function log() {\n        provider.log(_interpolate.apply(null, arguments));\n    }\n\n    function debug() {\n        if (_showLevel('debug')) {\n            provider.debug(_interpolate.apply(null, arguments));\n        }\n    }\n\n    function info() {\n        if (_showLevel('info')) {\n            provider.info(_interpolate.apply(null, arguments));\n        }\n    }\n\n    function warn() {\n        if (_showLevel('warn')) {\n            provider.warn(_interpolate.apply(null, arguments));\n        }\n    }\n\n    function error() {\n        if (_showLevel('error')) {\n            provider.error(_interpolate.apply(null, arguments));\n        }\n    }\n\n    /**\n     * Decide to log or not to log, based on the log levels 'weight'\n     * @param  {String}  showLevel [debug, info, warn, error, silent]\n     * @return {Boolean}\n     */\n    function _showLevel(showLevel) {\n        var result = false;\n        var currentLogLevel = LEVELS[logLevel];\n\n        if (currentLogLevel && (currentLogLevel <= LEVELS[showLevel])) {\n            result = true;\n        }\n\n        return result;\n    }\n\n    // make sure logged messages and its data are return interpolated\n    // make it possible for additional log data, such date/time or custom prefix.\n    function _interpolate() {\n        var fn = _.spread(util.format);\n        var result = fn(_.slice(arguments));\n\n        return result;\n    }\n\n    function isValidProvider(fnProvider) {\n        var result = true;\n\n        if (fnProvider && !_.isFunction(fnProvider)) {\n            throw new Error('[HPM] Log provider config error. Expecting a function.');\n        }\n\n        return result;\n    }\n\n    function isValidLevel(levelName) {\n        var validLevels = _.keys(LEVELS);\n        var isValid = _.includes(validLevels, levelName);\n\n        if (!isValid) {\n            throw new Error('[HPM] Log level error. Invalid logLevel.');\n        }\n\n        return isValid;\n    }\n}\n\n/**\n * -> normal proxy\n * => router\n * ~> pathRewrite\n * ≈> router + pathRewrite\n */\nfunction getArrow(originalPath, newPath, originalTarget, newTarget) {\n    var arrow = ['>'];\n    var isNewTarget = (originalTarget !== newTarget); // router\n    var isNewPath = (originalPath !== newPath); // pathRewrite\n\n    if (isNewPath && !isNewTarget) {arrow.unshift('~');} else if (!isNewPath && isNewTarget) {arrow.unshift('=');} else if (isNewPath && isNewTarget) {arrow.unshift('≈');} else {arrow.unshift('-');}\n\n    return arrow.join('');\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_http-proxy-middleware@0.17.4@http-proxy-middleware/lib/logger.js\n// module id = 10\n// module chunks = 0","module.exports = require(\"url\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"url\"\n// module id = 11\n// module chunks = 0","module.exports = require(\"util\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"util\"\n// module id = 12\n// module chunks = 0","var common   = exports,\n    url      = require('url'),\n    extend   = require('util')._extend,\n    required = require('requires-port');\n\nvar upgradeHeader = /(^|,)\\s*upgrade\\s*($|,)/i,\n    isSSL = /^https|wss/,\n    cookieDomainRegex = /(;\\s*domain=)([^;]+)/i;\n\n/**\n * Simple Regex for testing if protocol is https\n */\ncommon.isSSL = isSSL;\n/**\n * Copies the right headers from `options` and `req` to\n * `outgoing` which is then used to fire the proxied\n * request.\n *\n * Examples:\n *\n *    common.setupOutgoing(outgoing, options, req)\n *    // => { host: ..., hostname: ...}\n *\n * @param {Object} Outgoing Base object to be filled with required properties\n * @param {Object} Options Config object passed to the proxy\n * @param {ClientRequest} Req Request Object\n * @param {String} Forward String to select forward or target\n * \n * @return {Object} Outgoing Object with all required properties set\n *\n * @api private\n */\n\ncommon.setupOutgoing = function(outgoing, options, req, forward) {\n  outgoing.port = options[forward || 'target'].port ||\n                  (isSSL.test(options[forward || 'target'].protocol) ? 443 : 80);\n\n  ['host', 'hostname', 'socketPath', 'pfx', 'key',\n    'passphrase', 'cert', 'ca', 'ciphers', 'secureProtocol'].forEach(\n    function(e) { outgoing[e] = options[forward || 'target'][e]; }\n  );\n\n  outgoing.method = req.method;\n  outgoing.headers = extend({}, req.headers);\n\n  if (options.headers){\n    extend(outgoing.headers, options.headers);\n  }\n\n  if (options.auth) {\n    outgoing.auth = options.auth;\n  }\n  \n  if (options.ca) {\n      outgoing.ca = options.ca;\n  }\n\n  if (isSSL.test(options[forward || 'target'].protocol)) {\n    outgoing.rejectUnauthorized = (typeof options.secure === \"undefined\") ? true : options.secure;\n  }\n\n\n  outgoing.agent = options.agent || false;\n  outgoing.localAddress = options.localAddress;\n\n  //\n  // Remark: If we are false and not upgrading, set the connection: close. This is the right thing to do\n  // as node core doesn't handle this COMPLETELY properly yet.\n  //\n  if (!outgoing.agent) {\n    outgoing.headers = outgoing.headers || {};\n    if (typeof outgoing.headers.connection !== 'string'\n        || !upgradeHeader.test(outgoing.headers.connection)\n       ) { outgoing.headers.connection = 'close'; }\n  }\n\n\n  // the final path is target path + relative path requested by user:\n  var target = options[forward || 'target'];\n  var targetPath = target && options.prependPath !== false\n    ? (target.path || '')\n    : '';\n\n  //\n  // Remark: Can we somehow not use url.parse as a perf optimization?\n  //\n  var outgoingPath = !options.toProxy\n    ? (url.parse(req.url).path || '')\n    : req.url;\n\n  //\n  // Remark: ignorePath will just straight up ignore whatever the request's\n  // path is. This can be labeled as FOOT-GUN material if you do not know what\n  // you are doing and are using conflicting options.\n  //\n  outgoingPath = !options.ignorePath ? outgoingPath : '';\n\n  outgoing.path = common.urlJoin(targetPath, outgoingPath);\n\n  if (options.changeOrigin) {\n    outgoing.headers.host =\n      required(outgoing.port, options[forward || 'target'].protocol) && !hasPort(outgoing.host)\n        ? outgoing.host + ':' + outgoing.port\n        : outgoing.host;\n  }\n  return outgoing;\n};\n\n/**\n * Set the proper configuration for sockets,\n * set no delay and set keep alive, also set\n * the timeout to 0.\n *\n * Examples:\n *\n *    common.setupSocket(socket)\n *    // => Socket\n *\n * @param {Socket} Socket instance to setup\n * \n * @return {Socket} Return the configured socket.\n *\n * @api private\n */\n\ncommon.setupSocket = function(socket) {\n  socket.setTimeout(0);\n  socket.setNoDelay(true);\n\n  socket.setKeepAlive(true, 0);\n\n  return socket;\n};\n\n/**\n * Get the port number from the host. Or guess it based on the connection type.\n *\n * @param {Request} req Incoming HTTP request.\n *\n * @return {String} The port number.\n *\n * @api private\n */\ncommon.getPort = function(req) {\n  var res = req.headers.host ? req.headers.host.match(/:(\\d+)/) : '';\n\n  return res ?\n    res[1] :\n    common.hasEncryptedConnection(req) ? '443' : '80';\n};\n\n/**\n * Check if the request has an encrypted connection.\n *\n * @param {Request} req Incoming HTTP request.\n *\n * @return {Boolean} Whether the connection is encrypted or not.\n *\n * @api private\n */\ncommon.hasEncryptedConnection = function(req) {\n  return Boolean(req.connection.encrypted || req.connection.pair);\n};\n\n/**\n * OS-agnostic join (doesn't break on URLs like path.join does on Windows)>\n *\n * @return {String} The generated path.\n *\n * @api private\n */\n\ncommon.urlJoin = function() {\n    //\n    // We do not want to mess with the query string. All we want to touch is the path.\n    //\n  var args = Array.prototype.slice.call(arguments),\n      lastIndex = args.length - 1,\n      last = args[lastIndex],\n      lastSegs = last.split('?'),\n      retSegs;\n\n  args[lastIndex] = lastSegs.shift();\n\n  //\n  // Join all strings, but remove empty strings so we don't get extra slashes from\n  // joining e.g. ['', 'am']\n  //\n  retSegs = [\n    args.filter(Boolean).join('/')\n        .replace(/\\/+/g, '/')\n        .replace('http:/', 'http://')\n        .replace('https:/', 'https://')\n  ];\n\n  // Only join the query string if it exists so we don't have trailing a '?'\n  // on every request\n\n  // Handle case where there could be multiple ? in the URL.\n  retSegs.push.apply(retSegs, lastSegs);\n\n  return retSegs.join('?')\n};\n\n/**\n * Rewrites or removes the domain of a cookie header\n *\n * @param {String|Array} Header\n * @param {Object} Config, mapping of domain to rewritten domain.\n *                 '*' key to match any domain, null value to remove the domain.\n *\n * @api private\n */\ncommon.rewriteCookieDomain = function rewriteCookieDomain(header, config) {\n  if (Array.isArray(header)) {\n    return header.map(function (headerElement) {\n      return rewriteCookieDomain(headerElement, config);\n    });\n  }\n  return header.replace(cookieDomainRegex, function(match, prefix, previousDomain) {\n    var newDomain;\n    if (previousDomain in config) {\n      newDomain = config[previousDomain];\n    } else if ('*' in config) {\n      newDomain = config['*'];\n    } else {\n      //no match, return previous domain\n      return match;\n    }\n    if (newDomain) {\n      //replace domain\n      return prefix + newDomain;\n    } else {\n      //remove domain\n      return '';\n    }\n  });\n};\n\n/**\n * Check the host and see if it potentially has a port in it (keep it simple)\n *\n * @returns {Boolean} Whether we have one or not\n *\n * @api private\n */\nfunction hasPort(host) {\n  return !!~host.indexOf(':');\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_http-proxy@1.16.2@http-proxy/lib/http-proxy/common.js\n// module id = 13\n// module chunks = 0","module.exports = require(\"http\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"http\"\n// module id = 14\n// module chunks = 0","module.exports = require(\"https\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"https\"\n// module id = 15\n// module chunks = 0","'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\nvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} [once=false] Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Hold the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var events = this._events\n    , names = []\n    , name;\n\n  if (!events) return names;\n\n  for (name in events) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @param {Boolean} exists We only need to know if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events && this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} [context=this] The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} [context=this] The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Mixed} context Only remove listeners matching this context.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return this;\n\n  var listeners = this._events[evt]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn) {\n      if (\n           listeners.fn !== fn\n        || (once && !listeners.once)\n        || (context && listeners.context !== context)\n      ) {\n        events.push(listeners);\n      }\n    } else {\n      for (var i = 0, length = listeners.length; i < length; i++) {\n        if (\n             listeners[i].fn !== fn\n          || (once && !listeners[i].once)\n          || (context && listeners[i].context !== context)\n        ) {\n          events.push(listeners[i]);\n        }\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[evt] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[prefix ? prefix + event : event];\n  else this._events = prefix ? {} : Object.create(null);\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_eventemitter3@1.2.0@eventemitter3/index.js\n// module id = 16\n// module chunks = 0","var HPM  = require('./lib');\n\nmodule.exports = function(context, opts) {\n    return new HPM(context, opts);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_http-proxy-middleware@0.17.4@http-proxy-middleware/index.js\n// module id = 17\n// module chunks = 0","var _      = require('lodash');\nvar url    = require('url');\nvar logger = require('./logger').getInstance();\n\nmodule.exports = {\n    createConfig: createConfig\n};\n\nfunction createConfig(context, opts) {\n    // structure of config object to be returned\n    var config = {\n        context: undefined,\n        options: {}\n    };\n\n    // app.use('/api', proxy({target:'http://localhost:9000'}));\n    if (isContextless(context, opts)) {\n        config.context = '/';\n        config.options = _.assign(config.options, context);\n    }\n    // app.use('/api', proxy('http://localhost:9000'));\n    // app.use(proxy('http://localhost:9000/api'));\n    else if (isStringShortHand(context)) {\n        var oUrl   = url.parse(context);\n        var target = [oUrl.protocol, '//', oUrl.host].join('');\n\n        config.context = oUrl.pathname || '/';\n        config.options = _.assign(config.options, {target: target}, opts);\n\n        if (oUrl.protocol === 'ws:' || oUrl.protocol === 'wss:') {\n            config.options.ws = true;\n        }\n    // app.use('/api', proxy({target:'http://localhost:9000'}));\n    } else {\n        config.context = context;\n        config.options = _.assign(config.options, opts);\n    }\n\n    configureLogger(config.options);\n\n    if (!config.options.target) {\n        throw new Error('[HPM] Missing \"target\" option. Example: {target: \"http://www.example.org\"}');\n    }\n\n    // Legacy option.proxyHost\n    config.options = mapLegacyProxyHostOption(config.options);\n\n    // Legacy option.proxyTable > option.router\n    config.options = mapLegacyProxyTableOption(config.options);\n\n    return config;\n}\n\n/**\n * Checks if a String only target/config is provided.\n * This can be just the host or with the optional path.\n *\n * @example\n *      app.use('/api', proxy('http://localhost:9000'));\n        app.use(proxy('http://localhost:9000/api'));\n *\n * @param  {String}  context [description]\n * @return {Boolean}         [description]\n */\nfunction isStringShortHand(context) {\n    if (_.isString(context)) {\n        return (url.parse(context).host) ? true : false;\n    }\n}\n\n/**\n * Checks if a Object only config is provided, without a context.\n * In this case the all paths will be proxied.\n *\n * @example\n *     app.use('/api', proxy({target:'http://localhost:9000'}));\n *\n * @param  {Object}  context [description]\n * @param  {*}       opts    [description]\n * @return {Boolean}         [description]\n */\nfunction isContextless(context, opts) {\n    return (_.isPlainObject(context) && _.isEmpty(opts));\n}\n\nfunction mapLegacyProxyHostOption(options) {\n    // set options.headers.host when option.proxyHost is provided\n    if (options.proxyHost) {\n        logger.warn('*************************************');\n        logger.warn('[HPM] Deprecated \"option.proxyHost\"');\n        logger.warn('      Use \"option.changeOrigin\" or \"option.headers.host\" instead');\n        logger.warn('      \"option.proxyHost\" will be removed in future release.');\n        logger.warn('*************************************');\n\n        options.headers = options.headers || {};\n        options.headers.host = options.proxyHost;\n    }\n\n    return options;\n}\n\n// Warn deprecated proxyTable api usage\nfunction mapLegacyProxyTableOption(options) {\n    if (options.proxyTable) {\n        logger.warn('*************************************');\n        logger.warn('[HPM] Deprecated \"option.proxyTable\"');\n        logger.warn('      Use \"option.router\" instead');\n        logger.warn('      \"option.proxyTable\" will be removed in future release.');\n        logger.warn('*************************************');\n\n        options.router = _.clone(options.proxyTable);\n        _.omit(options, 'proxyTable');\n    }\n\n    return options;\n}\n\nfunction configureLogger(options) {\n    if (options.logLevel) {\n        logger.setLevel(options.logLevel);\n    }\n\n    if (options.logProvider) {\n        logger.setProvider(options.logProvider);\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_http-proxy-middleware@0.17.4@http-proxy-middleware/lib/config-factory.js\n// module id = 18\n// module chunks = 0","var _ = require('lodash');\nvar url = require('url');\nvar isGlob = require('is-glob');\nvar micromatch = require('micromatch');\n\nmodule.exports = {\n    match: matchContext\n};\n\nfunction matchContext(context, uri, req) {\n\n    // single path\n    if (isStringPath(context)) {\n        return matchSingleStringPath(context, uri);\n    }\n\n    // single glob path\n    if (isGlobPath(context)) {\n        return matchSingleGlobPath(context, uri);\n    }\n\n    // multi path\n    if (Array.isArray(context)) {\n        if (context.every(isStringPath)) {\n            return matchMultiPath(context, uri);\n        }\n        if (context.every(isGlobPath)) {\n            return matchMultiGlobPath(context, uri);\n        }\n\n        throw new Error('[HPM] Invalid context. Expecting something like: [\"/api\", \"/ajax\"] or [\"/api/**\", \"!**.html\"]');\n    }\n\n    // custom matching\n    if (_.isFunction(context)) {\n        var pathname = getUrlPathName(uri);\n        return context(pathname, req);\n    }\n\n    throw new Error('[HPM] Invalid context. Expecting something like: \"/api\" or [\"/api\", \"/ajax\"]');\n}\n\n/**\n * @param  {String} context '/api'\n * @param  {String} uri     'http://example.org/api/b/c/d.html'\n * @return {Boolean}\n */\nfunction matchSingleStringPath(context, uri) {\n    var pathname = getUrlPathName(uri);\n    return pathname.indexOf(context) === 0;\n}\n\nfunction matchSingleGlobPath(pattern, uri) {\n    var pathname = getUrlPathName(uri);\n    var matches = micromatch(pathname, pattern);\n    return matches && (matches.length > 0);\n}\n\nfunction matchMultiGlobPath(patternList, uri) {\n    return matchSingleGlobPath(patternList, uri);\n}\n\n/**\n * @param  {String} context ['/api', '/ajax']\n * @param  {String} uri     'http://example.org/api/b/c/d.html'\n * @return {Boolean}\n */\nfunction matchMultiPath(contextList, uri) {\n    for (var i = 0; i < contextList.length; i++) {\n        var context = contextList[i];\n        if (matchSingleStringPath(context, uri)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Parses URI and returns RFC 3986 path\n *\n * @param  {String} uri from req.url\n * @return {String}     RFC 3986 path\n */\nfunction getUrlPathName(uri) {\n    return uri && url.parse(uri).pathname;\n}\n\nfunction isStringPath(context) {\n    return _.isString(context) && !isGlob(context);\n}\n\nfunction isGlobPath(context) {\n    return isGlob(context);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_http-proxy-middleware@0.17.4@http-proxy-middleware/lib/context-matcher.js\n// module id = 19\n// module chunks = 0","var _      = require('lodash');\nvar logger = require('./logger').getInstance();\n\nmodule.exports = {\n    init: init,\n    getHandlers: getProxyEventHandlers\n};\n\nfunction init(proxy, opts) {\n    var handlers = getProxyEventHandlers(opts);\n\n    _.forIn(handlers, function(handler, eventName) {\n        proxy.on(eventName, handlers[eventName]);\n    });\n\n    logger.debug('[HPM] Subscribed to http-proxy events: ', _.keys(handlers));\n}\n\nfunction getProxyEventHandlers(opts) {\n    // https://github.com/nodejitsu/node-http-proxy#listening-for-proxy-events\n    var proxyEvents = ['error', 'proxyReq', 'proxyReqWs', 'proxyRes', 'open', 'close'];\n    var handlers = {};\n\n    _.forEach(proxyEvents, function(event) {\n        // all handlers for the http-proxy events are prefixed with 'on'.\n        // loop through options and try to find these handlers\n        // and add them to the handlers object for subscription in init().\n        var eventName = _.camelCase('on ' + event);\n        var fnHandler = _.get(opts, eventName);\n\n        if (_.isFunction(fnHandler)) {\n            handlers[event] = fnHandler;\n        }\n    });\n\n    // add default error handler in absence of error handler\n    if (!_.isFunction(handlers.error)) {\n        handlers.error = defaultErrorHandler;\n    }\n\n    // add default close handler in absence of close handler\n    if (!_.isFunction(handlers.close)) {\n        handlers.close = logClose;\n    }\n\n    return handlers;\n};\n\nfunction defaultErrorHandler(err, req, res) {\n    var host = (req.headers && req.headers.host);\n    var code = err.code;\n\n    if (res.writeHead && !res.headersSent) {\n        if (/HPE_INVALID/.test(code)) {\n            res.writeHead(502);\n        } else {\n            switch(code) {\n                case 'ECONNRESET':\n                case 'ENOTFOUND':\n                case 'ECONNREFUSED':\n                    res.writeHead(504);\n                    break;\n                default: res.writeHead(500);\n            }\n        }\n    }\n\n    res.end('Error occured while trying to proxy to: ' + host + req.url);\n}\n\nfunction logClose(req, socket, head) {\n    // view disconnected websocket connections\n    logger.info('[HPM] Client disconnected');\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_http-proxy-middleware@0.17.4@http-proxy-middleware/lib/handlers.js\n// module id = 20\n// module chunks = 0","var _              = require('lodash');\nvar httpProxy      = require('http-proxy');\nvar configFactory  = require('./config-factory');\nvar handlers       = require('./handlers');\nvar contextMatcher = require('./context-matcher');\nvar PathRewriter   = require('./path-rewriter');\nvar Router         = require('./router');\nvar logger         = require('./logger').getInstance();\nvar getArrow       = require('./logger').getArrow;\n\nmodule.exports = HttpProxyMiddleware;\n\nfunction HttpProxyMiddleware(context, opts) {\n    // https://github.com/chimurai/http-proxy-middleware/issues/57\n    var wsUpgradeDebounced  = _.debounce(handleUpgrade);\n    var wsInitialized       = false;\n    var config              = configFactory.createConfig(context, opts);\n    var proxyOptions        = config.options;\n\n    // create proxy\n    var proxy = httpProxy.createProxyServer({});\n    logger.info('[HPM] Proxy created:', config.context, ' -> ', proxyOptions.target);\n\n    var pathRewriter = PathRewriter.create(proxyOptions.pathRewrite); // returns undefined when \"pathRewrite\" is not provided\n\n    // attach handler to http-proxy events\n    handlers.init(proxy, proxyOptions);\n\n    // log errors for debug purpose\n    proxy.on('error', logError);\n\n    // https://github.com/chimurai/http-proxy-middleware/issues/19\n    // expose function to upgrade externally\n    middleware.upgrade = wsUpgradeDebounced;\n\n    return middleware;\n\n    function middleware(req, res, next) {\n        if (shouldProxy(config.context, req)) {\n            var activeProxyOptions = prepareProxyRequest(req);\n            proxy.web(req, res, activeProxyOptions);\n        } else {\n            next();\n        }\n\n        if (proxyOptions.ws === true) {\n            // use initial request to access the server object to subscribe to http upgrade event\n            catchUpgradeRequest(req.connection.server);\n        }\n    }\n\n    function catchUpgradeRequest(server) {\n        // subscribe once; don't subscribe on every request...\n        // https://github.com/chimurai/http-proxy-middleware/issues/113\n        if (!wsInitialized) {\n            server.on('upgrade', wsUpgradeDebounced);\n            wsInitialized = true;\n        }\n    }\n\n    function handleUpgrade(req, socket, head) {\n        // set to initialized when used externally\n        wsInitialized = true;\n\n        if (shouldProxy(config.context, req)) {\n            var activeProxyOptions = prepareProxyRequest(req);\n            proxy.ws(req, socket, head, activeProxyOptions);\n            logger.info('[HPM] Upgrading to WebSocket');\n        }\n    }\n\n    /**\n     * Determine whether request should be proxied.\n     *\n     * @private\n     * @return {Boolean}\n     */\n    function shouldProxy(context, req) {\n        var path = (req.originalUrl || req.url);\n        return contextMatcher.match(context, path, req);\n    }\n\n    /**\n     * Apply option.router and option.pathRewrite\n     * Order matters:\n          Router uses original path for routing;\n          NOT the modified path, after it has been rewritten by pathRewrite\n     */\n    function prepareProxyRequest(req) {\n        // https://github.com/chimurai/http-proxy-middleware/issues/17\n        // https://github.com/chimurai/http-proxy-middleware/issues/94\n        req.url = (req.originalUrl || req.url);\n\n        // store uri before it gets rewritten for logging\n        var originalPath = req.url;\n        var newProxyOptions = _.assign({}, proxyOptions);\n\n        // Apply in order:\n        // 1. option.router\n        // 2. option.pathRewrite\n        __applyRouter(req, newProxyOptions);\n        __applyPathRewrite(req, pathRewriter);\n\n        // debug logging for both http(s) and websockets\n        if (proxyOptions.logLevel === 'debug') {\n            var arrow = getArrow(originalPath, req.url, proxyOptions.target, newProxyOptions.target);\n            logger.debug('[HPM] %s %s %s %s', req.method, originalPath, arrow, newProxyOptions.target);\n        }\n\n        return newProxyOptions;\n    }\n\n    // Modify option.target when router present.\n    function __applyRouter(req, options) {\n        var newTarget;\n\n        if (options.router) {\n            newTarget = Router.getTarget(req, options);\n\n            if (newTarget) {\n                logger.debug('[HPM] Router new target: %s -> \"%s\"', options.target, newTarget);\n                options.target = newTarget;\n            }\n        }\n    }\n\n    // rewrite path\n    function __applyPathRewrite(req, pathRewriter) {\n        if (pathRewriter) {\n            var path = pathRewriter(req.url, req);\n\n            if (typeof path === 'string') {\n                req.url =  path;\n            } else {\n                logger.info('[HPM] pathRewrite: No rewritten path found. (%s)', req.url);\n            }\n        }\n    }\n\n    function logError(err, req, res) {\n        var hostname = (req.headers && req.headers.host) || (req.hostname || req.host);     // (websocket) || (node0.10 || node 4/5)\n        var target = proxyOptions.target.host || proxyOptions.target;\n        var errReference = 'https://nodejs.org/api/errors.html#errors_common_system_errors'; // link to Node Common Systems Errors page\n\n        logger.error('[HPM] Error occurred while trying to proxy request %s from %s to %s (%s) (%s)', req.url, hostname, target, err.code, errReference);\n    }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_http-proxy-middleware@0.17.4@http-proxy-middleware/lib/index.js\n// module id = 21\n// module chunks = 0","var _      = require('lodash');\nvar logger = require('./logger').getInstance();\n\nmodule.exports = {\n    create: createPathRewriter\n};\n\n/**\n * Create rewrite function, to cache parsed rewrite rules.\n *\n * @returns {function} Function to rewrite paths; This function should accept `path` (request.url) as parameter\n */\nfunction createPathRewriter(rewriteConfig) {\n    var rulesCache;\n\n    if (!isValidRewriteConfig(rewriteConfig)) {\n        return;\n    }\n\n    if (_.isFunction(rewriteConfig)) {\n        var customRewriteFn = rewriteConfig;\n        return customRewriteFn;\n    } else {\n        rulesCache = parsePathRewriteRules(rewriteConfig);\n        return rewritePath;\n    }\n\n    function rewritePath(path) {\n        var result = path;\n\n        _.forEach(rulesCache, function(rule) {\n            if (rule.regex.test(path)) {\n                result = result.replace(rule.regex, rule.value);\n                logger.debug('[HPM] Rewriting path from \"%s\" to \"%s\"', path, result);\n                return false;\n            }\n        });\n\n        return result;\n    }\n}\n\nfunction isValidRewriteConfig(rewriteConfig) {\n    if (_.isFunction(rewriteConfig)) {\n        return true;\n    } else if (!_.isEmpty(rewriteConfig) && _.isPlainObject(rewriteConfig)) {\n        return true;\n    } else if (_.isUndefined(rewriteConfig) ||\n               _.isNull(rewriteConfig) ||\n               _.isEqual(rewriteConfig, {})) {\n        return false;\n    } else {\n        throw new Error('[HPM] Invalid pathRewrite config. Expecting object with pathRewrite config or a rewrite function');\n    }\n}\n\nfunction parsePathRewriteRules(rewriteConfig) {\n    var rules = [];\n\n    if (_.isPlainObject(rewriteConfig)) {\n        _.forIn(rewriteConfig, function(value, key) {\n            rules.push({\n                regex: new RegExp(key),\n                value: rewriteConfig[key]\n            });\n            logger.info('[HPM] Proxy rewrite rule created: \"%s\" ~> \"%s\"', key, rewriteConfig[key]);\n        });\n    }\n\n    return rules;\n}\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_http-proxy-middleware@0.17.4@http-proxy-middleware/lib/path-rewriter.js\n// module id = 22\n// module chunks = 0","var _      = require('lodash');\nvar logger = require('./logger.js').getInstance();\n\nmodule.exports = {\n    getTarget: getTarget\n};\n\nfunction getTarget(req, config) {\n    var newTarget;\n    var router = config.router;\n\n    if (_.isPlainObject(router)) {\n        newTarget = getTargetFromProxyTable(req, router);\n    } else if (_.isFunction(router)) {\n        newTarget = router(req);\n    }\n\n    return newTarget;\n}\n\nfunction getTargetFromProxyTable(req, table) {\n    var result;\n    var host = req.headers.host;\n    var path = req.url;\n\n    var hostAndPath = host + path;\n\n    _.forIn(table, function(value, key) {\n        if (containsPath(key)) {\n\n            if (hostAndPath.indexOf(key) > -1) {    // match 'localhost:3000/api'\n                result = table[key];\n                logger.debug('[HPM] Router table match: \"%s\"', key);\n                return false;\n            }\n        } else {\n\n            if (key === host) {                     // match 'localhost:3000'\n                result = table[key];\n                logger.debug('[HPM] Router table match: \"%s\"', host);\n                return false;\n            }\n\n        }\n\n    });\n\n    return result;\n}\n\nfunction containsPath(v) {\n    return v.indexOf('/') > -1;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_http-proxy-middleware@0.17.4@http-proxy-middleware/lib/router.js\n// module id = 23\n// module chunks = 0","/*!\n * Caron dimonio, con occhi di bragia\n * loro accennando, tutte le raccoglie;\n * batte col remo qualunque s’adagia \n *\n * Charon the demon, with the eyes of glede,\n * Beckoning to them, collects them all together,\n * Beats with his oar whoever lags behind\n *          \n *          Dante - The Divine Comedy (Canto III)\n */\n\nmodule.exports = require('./lib/http-proxy');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_http-proxy@1.16.2@http-proxy/index.js\n// module id = 24\n// module chunks = 0"," // Use explicit /index.js to help browserify negociation in require '/lib/http-proxy' (!)\nvar ProxyServer = require('./http-proxy/index.js').Server;\n\n\n/**\n * Creates the proxy server.\n *\n * Examples:\n *\n *    httpProxy.createProxyServer({ .. }, 8000)\n *    // => '{ web: [Function], ws: [Function] ... }'\n *\n * @param {Object} Options Config object passed to the proxy\n *\n * @return {Object} Proxy Proxy object with handlers for `ws` and `web` requests\n *\n * @api public\n */\n\n\nfunction createProxyServer(options) {\n  /*\n   *  `options` is needed and it must have the following layout:\n   *\n   *  {\n   *    target : <url string to be parsed with the url module>\n   *    forward: <url string to be parsed with the url module>\n   *    agent  : <object to be passed to http(s).request>\n   *    ssl    : <object to be passed to https.createServer()>\n   *    ws     : <true/false, if you want to proxy websockets>\n   *    xfwd   : <true/false, adds x-forward headers>\n   *    secure : <true/false, verify SSL certificate>\n   *    toProxy: <true/false, explicitly specify if we are proxying to another proxy>\n   *    prependPath: <true/false, Default: true - specify whether you want to prepend the target's path to the proxy path>\n   *    ignorePath: <true/false, Default: false - specify whether you want to ignore the proxy path of the incoming request>\n   *    localAddress : <Local interface string to bind for outgoing connections>\n   *    changeOrigin: <true/false, Default: false - changes the origin of the host header to the target URL>\n   *    preserveHeaderKeyCase: <true/false, Default: false - specify whether you want to keep letter case of response header key >\n   *    auth   : Basic authentication i.e. 'user:password' to compute an Authorization header.\n   *    hostRewrite: rewrites the location hostname on (301/302/307/308) redirects, Default: null.\n   *    autoRewrite: rewrites the location host/port on (301/302/307/308) redirects based on requested host/port. Default: false.\n   *    protocolRewrite: rewrites the location protocol on (301/302/307/308) redirects to 'http' or 'https'. Default: null.\n   *  }\n   *\n   *  NOTE: `options.ws` and `options.ssl` are optional.\n   *    `options.target and `options.forward` cannot be\n   *    both missing\n   *  }\n   */\n\n  return new ProxyServer(options);\n}\n\n\nProxyServer.createProxyServer = createProxyServer;\nProxyServer.createServer      = createProxyServer;\nProxyServer.createProxy       = createProxyServer;\n\n\n\n\n/**\n * Export the proxy \"Server\" as the main export.\n */\nmodule.exports = ProxyServer;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_http-proxy@1.16.2@http-proxy/lib/http-proxy.js\n// module id = 25\n// module chunks = 0","var httpProxy = module.exports,\n    extend    = require('util')._extend,\n    parse_url = require('url').parse,\n    EE3       = require('eventemitter3'),\n    http      = require('http'),\n    https     = require('https'),\n    web       = require('./passes/web-incoming'),\n    ws        = require('./passes/ws-incoming');\n\nhttpProxy.Server = ProxyServer;\n\n/**\n * Returns a function that creates the loader for\n * either `ws` or `web`'s  passes.\n *\n * Examples:\n *\n *    httpProxy.createRightProxy('ws')\n *    // => [Function]\n *\n * @param {String} Type Either 'ws' or 'web'\n * \n * @return {Function} Loader Function that when called returns an iterator for the right passes\n *\n * @api private\n */\n\nfunction createRightProxy(type) {\n\n  return function(options) {\n    return function(req, res /*, [head], [opts] */) {\n      var passes = (type === 'ws') ? this.wsPasses : this.webPasses,\n          args = [].slice.call(arguments),\n          cntr = args.length - 1,\n          head, cbl;\n\n      /* optional args parse begin */\n      if(typeof args[cntr] === 'function') {\n        cbl = args[cntr];\n\n        cntr--;\n      }\n\n      if(\n        !(args[cntr] instanceof Buffer) &&\n        args[cntr] !== res\n      ) {\n        //Copy global options\n        options = extend({}, options);\n        //Overwrite with request options\n        extend(options, args[cntr]);\n\n        cntr--;\n      }\n\n      if(args[cntr] instanceof Buffer) {\n        head = args[cntr];\n      }\n\n      /* optional args parse end */\n\n      ['target', 'forward'].forEach(function(e) {\n        if (typeof options[e] === 'string')\n          options[e] = parse_url(options[e]);\n      });\n\n      if (!options.target && !options.forward) {\n        return this.emit('error', new Error('Must provide a proper URL as target'));\n      }\n\n      for(var i=0; i < passes.length; i++) {\n        /**\n         * Call of passes functions\n         * pass(req, res, options, head)\n         *\n         * In WebSockets case the `res` variable\n         * refer to the connection socket\n         * pass(req, socket, options, head)\n         */\n        if(passes[i](req, res, options, head, this, cbl)) { // passes can return a truthy value to halt the loop\n          break;\n        }\n      }\n    };\n  };\n}\nhttpProxy.createRightProxy = createRightProxy;\n\nfunction ProxyServer(options) {\n  EE3.call(this);\n\n  options = options || {};\n  options.prependPath = options.prependPath === false ? false : true;\n\n  this.web = this.proxyRequest           = createRightProxy('web')(options);\n  this.ws  = this.proxyWebsocketRequest  = createRightProxy('ws')(options);\n  this.options = options;\n\n  this.webPasses = Object.keys(web).map(function(pass) {\n    return web[pass];\n  });\n\n  this.wsPasses = Object.keys(ws).map(function(pass) {\n    return ws[pass];\n  });\n\n  this.on('error', this.onError, this);\n\n}\n\nrequire('util').inherits(ProxyServer, EE3);\n\nProxyServer.prototype.onError = function (err) {\n  //\n  // Remark: Replicate node core behavior using EE3\n  // so we force people to handle their own errors\n  //\n  if(this.listeners('error').length === 1) {\n    throw err;\n  }\n};\n\nProxyServer.prototype.listen = function(port, hostname) {\n  var self    = this,\n      closure = function(req, res) { self.web(req, res); };\n\n  this._server  = this.options.ssl ?\n    https.createServer(this.options.ssl, closure) :\n    http.createServer(closure);\n\n  if(this.options.ws) {\n    this._server.on('upgrade', function(req, socket, head) { self.ws(req, socket, head); });\n  }\n\n  this._server.listen(port, hostname);\n\n  return this;\n};\n\nProxyServer.prototype.close = function(callback) {\n  var self = this;\n  if (this._server) {\n    this._server.close(done);\n  }\n\n  // Wrap callback to nullify server after all open connections are closed.\n  function done() {\n    self._server = null;\n    if (callback) {\n      callback.apply(null, arguments);\n    }\n  };\n};\n\nProxyServer.prototype.before = function(type, passName, callback) {\n  if (type !== 'ws' && type !== 'web') {\n    throw new Error('type must be `web` or `ws`');\n  }\n  var passes = (type === 'ws') ? this.wsPasses : this.webPasses,\n      i = false;\n\n  passes.forEach(function(v, idx) {\n    if(v.name === passName) i = idx;\n  })\n\n  if(i === false) throw new Error('No such pass');\n\n  passes.splice(i, 0, callback);\n};\nProxyServer.prototype.after = function(type, passName, callback) {\n  if (type !== 'ws' && type !== 'web') {\n    throw new Error('type must be `web` or `ws`');\n  }\n  var passes = (type === 'ws') ? this.wsPasses : this.webPasses,\n      i = false;\n\n  passes.forEach(function(v, idx) {\n    if(v.name === passName) i = idx;\n  })\n\n  if(i === false) throw new Error('No such pass');\n\n  passes.splice(i++, 0, callback);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_http-proxy@1.16.2@http-proxy/lib/http-proxy/index.js\n// module id = 26\n// module chunks = 0","var http   = require('http'),\n    https  = require('https'),\n    web_o  = require('./web-outgoing'),\n    common = require('../common');\n\nweb_o = Object.keys(web_o).map(function(pass) {\n  return web_o[pass];\n});\n\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, res, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n\nmodule.exports = {\n\n  /**\n   * Sets `content-length` to '0' if request is of DELETE type.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  deleteLength: function deleteLength(req, res, options) {\n    if((req.method === 'DELETE' || req.method === 'OPTIONS')\n       && !req.headers['content-length']) {\n      req.headers['content-length'] = '0';\n      delete req.headers['transfer-encoding'];\n    }\n  },\n\n  /**\n   * Sets timeout in request socket if it was specified in options.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  timeout: function timeout(req, res, options) {\n    if(options.timeout) {\n      req.socket.setTimeout(options.timeout);\n    }\n  },\n\n  /**\n   * Sets `x-forwarded-*` headers if specified in config.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  XHeaders: function XHeaders(req, res, options) {\n    if(!options.xfwd) return;\n\n    var encrypted = req.isSpdy || common.hasEncryptedConnection(req);\n    var values = {\n      for  : req.connection.remoteAddress || req.socket.remoteAddress,\n      port : common.getPort(req),\n      proto: encrypted ? 'https' : 'http'\n    };\n\n    ['for', 'port', 'proto'].forEach(function(header) {\n      req.headers['x-forwarded-' + header] =\n        (req.headers['x-forwarded-' + header] || '') +\n        (req.headers['x-forwarded-' + header] ? ',' : '') +\n        values[header];\n    });\n\n    req.headers['x-forwarded-host'] = req.headers['host'] || '';\n  },\n\n  /**\n   * Does the actual proxying. If `forward` is enabled fires up\n   * a ForwardStream, same happens for ProxyStream. The request\n   * just dies otherwise.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  stream: function stream(req, res, options, _, server, clb) {\n\n    // And we begin!\n    server.emit('start', req, res, options.target || options.forward);\n\n    if(options.forward) {\n      // If forward enable, so just pipe the request\n      var forwardReq = (options.forward.protocol === 'https:' ? https : http).request(\n        common.setupOutgoing(options.ssl || {}, options, req, 'forward')\n      );\n\n      // error handler (e.g. ECONNRESET, ECONNREFUSED)\n      // Handle errors on incoming request as well as it makes sense to\n      var forwardError = createErrorHandler(forwardReq, options.forward);\n      req.on('error', forwardError);\n      forwardReq.on('error', forwardError);\n\n      (options.buffer || req).pipe(forwardReq);\n      if(!options.target) { return res.end(); }\n    }\n\n    // Request initalization\n    var proxyReq = (options.target.protocol === 'https:' ? https : http).request(\n      common.setupOutgoing(options.ssl || {}, options, req)\n    );\n\n    // Enable developers to modify the proxyReq before headers are sent\n    proxyReq.on('socket', function(socket) {\n      if(server) { server.emit('proxyReq', proxyReq, req, res, options); }\n    });\n\n    // allow outgoing socket to timeout so that we could\n    // show an error page at the initial request\n    if(options.proxyTimeout) {\n      proxyReq.setTimeout(options.proxyTimeout, function() {\n         proxyReq.abort();\n      });\n    }\n\n    // Ensure we abort proxy if request is aborted\n    req.on('aborted', function () {\n      proxyReq.abort();\n    });\n\n    // handle errors in proxy and incoming request, just like for forward proxy\n    var proxyError = createErrorHandler(proxyReq, options.target);\n    req.on('error', proxyError);\n    proxyReq.on('error', proxyError);\n\n    function createErrorHandler(proxyReq, url) {\n      return function proxyError(err) {\n        if (req.socket.destroyed && err.code === 'ECONNRESET') {\n          server.emit('econnreset', err, req, res, url);\n          return proxyReq.abort();\n        }\n\n        if (clb) {\n          clb(err, req, res, url);\n        } else {\n          server.emit('error', err, req, res, url);\n        }\n      }\n    }\n\n    (options.buffer || req).pipe(proxyReq);\n\n    proxyReq.on('response', function(proxyRes) {\n      if(server) { server.emit('proxyRes', proxyRes, req, res); }\n      for(var i=0; i < web_o.length; i++) {\n        if(web_o[i](req, res, proxyRes, options)) { break; }\n      }\n\n      // Allow us to listen when the proxy has completed\n      proxyRes.on('end', function () {\n        server.emit('end', req, res, proxyRes);\n      });\n\n      proxyRes.pipe(res);\n    });\n\n    //proxyReq.end();\n  }\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_http-proxy@1.16.2@http-proxy/lib/http-proxy/passes/web-incoming.js\n// module id = 27\n// module chunks = 0","var url    = require('url'),\n    common = require('../common');\n\n\nvar redirectRegex = /^201|30(1|2|7|8)$/;\n\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, res, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\nmodule.exports = { // <--\n\n  /**\n   * If is a HTTP 1.0 request, remove chunk headers\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   *\n   * @api private\n   */\n  removeChunked: function removeChunked(req, res, proxyRes) {\n    if (req.httpVersion === '1.0') {\n      delete proxyRes.headers['transfer-encoding'];\n    }\n  },\n\n  /**\n   * If is a HTTP 1.0 request, set the correct connection header\n   * or if connection header not present, then use `keep-alive`\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   *\n   * @api private\n   */\n  setConnection: function setConnection(req, res, proxyRes) {\n    if (req.httpVersion === '1.0') {\n      proxyRes.headers.connection = req.headers.connection || 'close';\n    } else if (req.httpVersion !== '2.0' && !proxyRes.headers.connection) {\n      proxyRes.headers.connection = req.headers.connection || 'keep-alive';\n    }\n  },\n\n  setRedirectHostRewrite: function setRedirectHostRewrite(req, res, proxyRes, options) {\n    if ((options.hostRewrite || options.autoRewrite || options.protocolRewrite)\n        && proxyRes.headers['location']\n        && redirectRegex.test(proxyRes.statusCode)) {\n      var target = url.parse(options.target);\n      var u = url.parse(proxyRes.headers['location']);\n\n      // make sure the redirected host matches the target host before rewriting\n      if (target.host != u.host) {\n        return;\n      }\n\n      if (options.hostRewrite) {\n        u.host = options.hostRewrite;\n      } else if (options.autoRewrite) {\n        u.host = req.headers['host'];\n      }\n      if (options.protocolRewrite) {\n        u.protocol = options.protocolRewrite;\n      }\n\n      proxyRes.headers['location'] = u.format();\n    }\n  },\n  /**\n   * Copy headers from proxyResponse to response\n   * set each header in response object.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   * @param {Object} Options options.cookieDomainRewrite: Config to rewrite cookie domain\n   *\n   * @api private\n   */\n  writeHeaders: function writeHeaders(req, res, proxyRes, options) {\n    var rewriteCookieDomainConfig = options.cookieDomainRewrite,\n        preserveHeaderKeyCase = options.preserveHeaderKeyCase,\n        rawHeaderKeyMap,\n        setHeader = function(key, header) {\n          if (header == undefined) return;\n          if (rewriteCookieDomainConfig && key.toLowerCase() === 'set-cookie') {\n            header = common.rewriteCookieDomain(header, rewriteCookieDomainConfig);\n          }\n          res.setHeader(String(key).trim(), header);\n        };\n\n    if (typeof rewriteCookieDomainConfig === 'string') { //also test for ''\n      rewriteCookieDomainConfig = { '*': rewriteCookieDomainConfig };\n    }\n\n    // message.rawHeaders is added in: v0.11.6\n    // https://nodejs.org/api/http.html#http_message_rawheaders\n    if (preserveHeaderKeyCase && proxyRes.rawHeaders != undefined) {\n      rawHeaderKeyMap = {};\n      for (var i = 0; i < proxyRes.rawHeaders.length; i += 2) {\n        var key = proxyRes.rawHeaders[i];\n        rawHeaderKeyMap[key.toLowerCase()] = key;\n      }\n    }\n\n    Object.keys(proxyRes.headers).forEach(function(key) {\n      var header = proxyRes.headers[key];\n      if (preserveHeaderKeyCase && rawHeaderKeyMap) {\n        key = rawHeaderKeyMap[key] || key;\n      }\n      setHeader(key, header);\n    });\n  },\n\n  /**\n   * Set the statusCode from the proxyResponse\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   *\n   * @api private\n   */\n  writeStatusCode: function writeStatusCode(req, res, proxyRes) {\n    // From Node.js docs: response.writeHead(statusCode[, statusMessage][, headers])\n    if(proxyRes.statusMessage) {\n      res.writeHead(proxyRes.statusCode, proxyRes.statusMessage);\n    } else {\n      res.writeHead(proxyRes.statusCode);\n    }\n  }\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_http-proxy@1.16.2@http-proxy/lib/http-proxy/passes/web-outgoing.js\n// module id = 28\n// module chunks = 0","var http   = require('http'),\n    https  = require('https'),\n    common = require('../common');\n\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, socket, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n/*\n * Websockets Passes\n *\n */\n\n\nmodule.exports = {\n  /**\n   * WebSocket requests must have the `GET` method and\n   * the `upgrade:websocket` header\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   *\n   * @api private\n   */\n\n  checkMethodAndHeader : function checkMethodAndHeader(req, socket) {\n    if (req.method !== 'GET' || !req.headers.upgrade) {\n      socket.destroy();\n      return true;\n    }\n\n    if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n      socket.destroy();\n      return true;\n    }\n  },\n\n  /**\n   * Sets `x-forwarded-*` headers if specified in config.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  XHeaders : function XHeaders(req, socket, options) {\n    if(!options.xfwd) return;\n\n    var values = {\n      for  : req.connection.remoteAddress || req.socket.remoteAddress,\n      port : common.getPort(req),\n      proto: common.hasEncryptedConnection(req) ? 'wss' : 'ws'\n    };\n\n    ['for', 'port', 'proto'].forEach(function(header) {\n      req.headers['x-forwarded-' + header] =\n        (req.headers['x-forwarded-' + header] || '') +\n        (req.headers['x-forwarded-' + header] ? ',' : '') +\n        values[header];\n    });\n  },\n\n  /**\n   * Does the actual proxying. Make the request and upgrade it\n   * send the Switching Protocols request and pipe the sockets.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n  stream : function stream(req, socket, options, head, server, clb) {\n    common.setupSocket(socket);\n\n    if (head && head.length) socket.unshift(head);\n\n\n    var proxyReq = (common.isSSL.test(options.target.protocol) ? https : http).request(\n      common.setupOutgoing(options.ssl || {}, options, req)\n    );\n\n    // Enable developers to modify the proxyReq before headers are sent\n    if (server) { server.emit('proxyReqWs', proxyReq, req, socket, options, head); }\n\n    // Error Handler\n    proxyReq.on('error', onOutgoingError);\n    proxyReq.on('response', function (res) {\n      // if upgrade event isn't going to happen, close the socket\n      if (!res.upgrade) socket.end();\n    });\n\n    proxyReq.on('upgrade', function(proxyRes, proxySocket, proxyHead) {\n      proxySocket.on('error', onOutgoingError);\n\n      // Allow us to listen when the websocket has completed\n      proxySocket.on('end', function () {\n        server.emit('close', proxyRes, proxySocket, proxyHead);\n      });\n\n      // The pipe below will end proxySocket if socket closes cleanly, but not\n      // if it errors (eg, vanishes from the net and starts returning\n      // EHOSTUNREACH). We need to do that explicitly.\n      socket.on('error', function () {\n        proxySocket.end();\n      });\n\n      common.setupSocket(proxySocket);\n\n      if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead);\n\n      //\n      // Remark: Handle writing the headers to the socket when switching protocols\n      // Also handles when a header is an array\n      //\n      socket.write(\n        Object.keys(proxyRes.headers).reduce(function (head, key) {\n          var value = proxyRes.headers[key];\n\n          if (!Array.isArray(value)) {\n            head.push(key + ': ' + value);\n            return head;\n          }\n\n          for (var i = 0; i < value.length; i++) {\n            head.push(key + ': ' + value[i]);\n          }\n          return head;\n        }, ['HTTP/1.1 101 Switching Protocols'])\n        .join('\\r\\n') + '\\r\\n\\r\\n'\n      );\n\n      proxySocket.pipe(socket).pipe(proxySocket);\n\n      server.emit('open', proxySocket);\n      server.emit('proxySocket', proxySocket);  //DEPRECATED.\n    });\n\n    return proxyReq.end(); // XXX: CHECK IF THIS IS THIS CORRECT\n\n    function onOutgoingError(err) {\n      if (clb) {\n        clb(err, req, socket);\n      } else {\n        server.emit('error', err, req, socket);\n      }\n      socket.end();\n    }\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_http-proxy@1.16.2@http-proxy/lib/http-proxy/passes/ws-incoming.js\n// module id = 29\n// module chunks = 0","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;\r\n    return { next: verb(0), \"throw\": verb(1), \"return\": verb(2) };\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\n/**\r\n * Inject raw response, so we can know if middleware has responsed.\r\n */\r\nfunction makeInjectedResponse(koaCtx, /*markHandled,*/ whenEnded) {\r\n    var res = koaCtx.res;\r\n    res.on('close', whenEnded).on('finish', whenEnded);\r\n    var dummyRes = Object.create(res);\r\n    [\r\n        'setHeader',\r\n        'writeHead',\r\n        'write',\r\n        'end'\r\n    ].forEach(function (name) {\r\n        dummyRes[name] = function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            res[name].apply(res, args);\r\n            // koa2.0 initial assign statusCode to 404, reset to 200\r\n            if (res.statusCode === 404) {\r\n                res.statusCode = 200;\r\n            }\r\n            // markHandled();\r\n        };\r\n    });\r\n    [\r\n        'statusCode',\r\n        'statusMessage'\r\n    ].forEach(function (name) {\r\n        dummyRes.__defineSetter__(name, function (value) {\r\n            res[name] = value;\r\n            // markHandled();\r\n        });\r\n    });\r\n    return dummyRes;\r\n}\r\n/**\r\n * The middleware function does include the `next` callback so only resolve\r\n * the Promise when it's called. If it's never called, the middleware stack\r\n * completion will stall\r\n */\r\nfunction handler(ctx, connectMiddleware) {\r\n    return new Promise(function (resolve, reject) {\r\n        // let hasHandled = false;\r\n        // (req, res)\r\n        var args = [\r\n            ctx.req,\r\n            makeInjectedResponse(ctx, \r\n            // () => {\r\n            //   // hasHandled = true;\r\n            // },\r\n            function () {\r\n                resolve(false);\r\n            })\r\n        ];\r\n        var assumeSync = true;\r\n        // (req, res, next) or (err, req, res, next)\r\n        if (connectMiddleware.length >= 3) {\r\n            args.push(function (err) {\r\n                if (err)\r\n                    reject(err);\r\n                else\r\n                    resolve(true);\r\n            });\r\n            assumeSync = false;\r\n        }\r\n        // (err, req, res, next)\r\n        if (connectMiddleware.length >= 4) {\r\n            args.unshift(null);\r\n        }\r\n        connectMiddleware.apply(void 0, args);\r\n        /**\r\n         * If the middleware function does not declare receiving the `next` callback\r\n         * assume that it's synchronous.\r\n         */\r\n        if (assumeSync /*&& !hasHandled*/) {\r\n            resolve(true);\r\n        }\r\n    });\r\n}\r\n/**\r\n * Returns a Koa middleware function that varies its async logic based on if the\r\n * given middleware function declares at least 3 parameters, i.e. includes\r\n * the `next` callback function\r\n */\r\nfunction koaConnect(connectMiddleware) {\r\n    var _this = this;\r\n    return function (ctx, next) { return __awaiter(_this, void 0, void 0, function () {\r\n        var goNext, err_1;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    ctx.respond = false;\r\n                    _a.label = 1;\r\n                case 1:\r\n                    _a.trys.push([1, 3, , 4]);\r\n                    return [4 /*yield*/, handler(ctx, connectMiddleware)];\r\n                case 2:\r\n                    goNext = _a.sent();\r\n                    if (goNext) {\r\n                        ctx.respond = true;\r\n                        return [2 /*return*/, next()];\r\n                    }\r\n                    return [3 /*break*/, 4];\r\n                case 3:\r\n                    err_1 = _a.sent();\r\n                    ctx.respond = true;\r\n                    throw err_1;\r\n                case 4:\r\n                    ;\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    }); };\r\n}\r\nmodule.exports = koaConnect;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_koa2-connect@1.0.2@koa2-connect/dist/index.js\n// module id = 30\n// module chunks = 0","'use strict';\n\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\nmodule.exports = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_requires-port@1.0.0@requires-port/index.js\n// module id = 31\n// module chunks = 0","module.exports = require(\"is-glob\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"is-glob\"\n// module id = 32\n// module chunks = 0","module.exports = require(\"micromatch\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"micromatch\"\n// module id = 33\n// module chunks = 0","export default {\n  'appName': 'mockServer',\n  'appMiniName': 'M',\n  'whiteList': ['/login'],\n  'apiBaseURL': 'api',\n  'proxy': {\n    target: 'https://www.easy-mock.com/mock/5a7bac516347684a0857e274/mserver',\n    changeOrigin: true,\n    pathRewrite: {\n      '^/api': ''\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./utils/config.js"],"sourceRoot":""}